import requests
import json
import os
from typing import Tuple, List

class GeminiChatModerator:
    def __init__(self, api_key: str = None):
        self.api_key = api_key or os.getenv('GEMINI_API_KEY', 'AIzaSyAiIWXFxKn7Iogvu5giZRTcZDeh36tx6WI')
        self.api_url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent"
        
        # System prompt that defines AI's behavior
        self.system_prompt = """You are a helpful, respectful, and honest assistant. 
Always provide accurate and harmless information. If you're unsure about something, 
say so rather than making up information. Be concise and helpful in your responses."""
        
        # Banned keywords for moderation
        self.banned_keywords = ["kill", "hack", "bomb", "harm", "violence", "dangerous", "explosive"]
    
    def moderate_input(self, user_prompt: str) -> Tuple[bool, str]:
        if not user_prompt or not user_prompt.strip():
            return False, "Input cannot be empty"
            
        user_prompt_lower = user_prompt.lower()
        
        for keyword in self.banned_keywords:
            if keyword in user_prompt_lower:
                return False, f"Input contains banned keyword: '{keyword}'"
        
        return True, "Input passed moderation"
    
    def moderate_output(self, ai_response: str) -> Tuple[str, bool]:
        if not ai_response:
            return "", False
            
        had_violations = False
        moderated_response = ai_response
        
        for keyword in self.banned_keywords:
            if keyword in ai_response.lower():
                had_violations = True
                # Replace all occurrences (case insensitive)
                moderated_response = self._replace_case_insensitive(
                    moderated_response, keyword, '[REDACTED]'
                )
        
        return moderated_response, had_violations
    
    def _replace_case_insensitive(self, text: str, old: str, new: str) -> str:
        import re
        return re.compile(re.escape(old), re.IGNORECASE).sub(new, text)
    
    def call_gemini_api(self, user_prompt: str) -> Tuple[str, bool]:
        headers = {
            "Content-Type": "application/json",
            "X-goog-api-key": self.api_key
        }
        
        # Combine system prompt with user prompt for Gemini
        full_prompt = f"{self.system_prompt}\n\nUser: {user_prompt}\nAssistant:"
        
        payload = {
            "contents": [
                {
                    "parts": [
                        {
                            "text": full_prompt
                        }
                    ]
                }
            ],
            "generationConfig": {
                "temperature": 0.7,
                "maxOutputTokens": 500,
            }
        }
        
        try:
            response = requests.post(
                f"{self.api_url}?key={self.api_key}", 
                headers=headers, 
                json=payload, 
                timeout=30
            )
            response.raise_for_status()
            
            result = response.json()
            
            # Extract the response text from Gemini's response format
            if 'candidates' in result and len(result['candidates']) > 0:
                ai_response = result['candidates'][0]['content']['parts'][0]['text']
                return ai_response.strip(), True
            else:
                return "Error: No response generated by AI", False
            
        except requests.exceptions.RequestException as e:
            return f"API Error: {str(e)}", False
        except KeyError as e:
            return f"Unexpected API response format: {str(e)}", False
        except Exception as e:
            return f"Unexpected error: {str(e)}", False
    
    def process_user_prompt(self, user_prompt: str) -> str:
        # Step 1: Input moderation
        is_safe, message = self.moderate_input(user_prompt)
        if not is_safe:
            return "Your input/output violated the moderation policy."
        
        # Step 2: Call Gemini API
        ai_response, success = self.call_gemini_api(user_prompt)
        if not success:
            return f"Error: {ai_response}"
        
        # Step 3: Output moderation
        moderated_response, had_violations = self.moderate_output(ai_response)
        
        # Step 4: Return final response
        if had_violations:
            return "Your input/output violated the moderation policy."
        
        return moderated_response


def main():
    # Initialize the moderator with your API key
    moderator = GeminiChatModerator(api_key="AIzaSyAiIWXFxKn7Iogvu5giZRTcZDeh36tx6WI")
    
    print("ðŸ¤– Gemini AI Chat Moderator")
    print("===========================")
    print("Type 'quit' or 'exit' to end the session")
    print("-" * 40)
    
    while True:
        try:
            # Get user input
            user_prompt = input("\nYou: ").strip()
            
            if user_prompt.lower() in ['quit', 'exit', 'bye']:
                print("Goodbye! ðŸ‘‹")
                break
            
            if not user_prompt:
                print("Please enter a message.")
                continue
            
            # Process the prompt
            print("Processing...")
            response = moderator.process_user_prompt(user_prompt)
            print(f"AI: {response}")
            
        except KeyboardInterrupt:
            print("\n\nSession ended by user. Goodbye! ðŸ‘‹")
            break
        except Exception as e:
            print(f"An error occurred: {str(e)}")


# Web API version using Flask
from flask import Flask, request, jsonify

app = Flask(__name__)
moderator = GeminiChatModerator(api_key="AIzaSyAiIWXFxKn7Iogvu5giZRTcZDeh36tx6WI")

@app.route('/api/chat', methods=['POST'])
def chat_endpoint():
    try:
        data = request.get_json()
        
        if not data or 'prompt' not in data:
            return jsonify({'error': 'Missing prompt field'}), 400
        
        user_prompt = data['prompt']
        
        if not isinstance(user_prompt, str) or not user_prompt.strip():
            return jsonify({'error': 'Prompt must be a non-empty string'}), 400
        
        response = moderator.process_user_prompt(user_prompt)
        
        return jsonify({
            'user_prompt': user_prompt,
            'ai_response': response,
            'status': 'success'
        })
        
    except Exception as e:
        return jsonify({'error': f'Server error: {str(e)}'}), 500

@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({'status': 'healthy', 'service': 'Gemini AI Chat Moderator'})


if __name__ == "__main__":
    print("Starting Gemini AI Chat Moderator...")
    print(f"API Key: {moderator.api_key[:10]}...")
    
main()